<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Adventure Platformer Ultimate</title>
<style>
body { margin:0; overflow:hidden; background:#87ceeb; }
canvas { display:block; margin:auto; background:#cfefff; }
</style>
</head>
<body>

<canvas id="game" width="1100" height="520"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let keys = {};
addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

const gravity = 0.6;
let cameraX = 0;
let levelNumber = 1;
let gameOver = false;
let levelComplete = false;

const player = {
  x:120,y:200,w:45,h:80,
  vx:0,vy:0,
  speed:4,
  jump:-13,
  onGround:false,
  doubleJump:true,
  facing:1,
  lives:5,
  shootCooldown:0,
  dashCooldown:0,
  dashTimer:0,
  shield:false,
  shieldEnergy:100,
  invincible:false,
  invTimer:0,
  gliding:false
};

let level;
let bullets=[];
let playerBullets=[];

function hit(a,b){
  return a.x<b.x+b.w && a.x+a.w>b.x &&
         a.y<b.y+b.h && a.y+a.h>b.y;
}

function generateLevel(n){
  const platforms=[], spikes=[], coins=[], enemies=[];
  let x=0;
  const ground=420;
  const length=1500+n*200;

  while(x<length){
    const w=250;
    const y=ground-Math.random()*120;
    platforms.push({x,y,w,h:20});

    if(x>500 && Math.random()<0.35){
      const spikeWidth=60;
      spikes.push({
        x:x+Math.random()*(w-spikeWidth),
        y:y-20,
        w:spikeWidth,
        h:20,
        left:x,
        right:x+w-spikeWidth,
        dir:Math.random()<0.5?1:-1
      });
    }

    coins.push({x:x+w/2,y:y-60,collected:false});

    if(Math.random()<0.3){
      enemies.push({
        x:x+w/2,y:y-70,w:40,h:70,
        shootTimer:100
      });
    }

    x+=w+150;
  }

  return {
    platforms,
    spikes,
    coins,
    enemies,
    trophy:{x:x+100,y:260,w:30,h:40}
  };
}

level=generateLevel(levelNumber);

function damagePlayer(){
  if(player.invincible) return;
  player.lives--;
  player.invincible=true;
  player.invTimer=60;
  if(player.lives<=0) gameOver=true;
}

function update(){
if(gameOver||levelComplete)return;

const spikeSpeed=2+levelNumber*0.3;
const fireRate=Math.max(40,120-levelNumber*5);

// Movement
player.vx=0;
if(keys["arrowright"]){player.vx=player.speed;player.facing=1;}
if(keys["arrowleft"]){player.vx=-player.speed;player.facing=-1;}

// Dash
if(keys["x"] && player.dashCooldown<=0){
  player.dashTimer=15;
  player.dashCooldown=90;
  player.invincible=true;
  player.invTimer=20;
}
if(player.dashTimer>0){
  player.vx=player.facing*15;
  player.dashTimer--;
}
if(player.dashCooldown>0)player.dashCooldown--;

// Jump
if(keys["arrowup"]){
  if(player.onGround){
    player.vy=player.jump;
    player.onGround=false;
    player.doubleJump=true;
  }else if(player.doubleJump){
    player.vy=player.jump;
    player.doubleJump=false;
  }
}

// GLIDE (STRONGER)
player.gliding = keys["g"] && !player.onGround;

if(player.gliding){
  player.vy += 0.05;          // reduced gravity
  if(player.vy > -2){
    player.vy -= 0.4;         // upward lift
  }
  if(player.vy < -4){
    player.vy = -4;           // cap upward speed
  }
}else{
  player.vy += gravity;
}

player.x+=player.vx;
player.y+=player.vy;
player.onGround=false;

// Platform collision
level.platforms.forEach(p=>{
  if(hit(player,p)&&player.vy>=0){
    player.y=p.y-player.h;
    player.vy=0;
    player.onGround=true;
  }
});

// Spikes
level.spikes.forEach(s=>{
  s.x+=spikeSpeed*s.dir;
  if(s.x<=s.left||s.x>=s.right)s.dir*=-1;

  if(hit(player,s)&&player.vy>=0){
    player.y=s.y-player.h;
    player.vy=0;
    player.onGround=true;
    damagePlayer();
  }
});

// Shield
if(keys["shift"] && player.shieldEnergy>0){
  player.shield=true;
  player.shieldEnergy-=1;
}else{
  player.shield=false;
  if(player.shieldEnergy<100)player.shieldEnergy+=0.5;
}

// Shooters
level.enemies.forEach(e=>{
  if(player.x<e.x)e.x-=1;
  if(player.x>e.x)e.x+=1;

  e.shootTimer--;
  if(e.shootTimer<=0){
    bullets.push({x:e.x,y:e.y+30,vx:(player.x<e.x?-6:6)});
    e.shootTimer=fireRate;
  }
});

// Enemy bullets
bullets.forEach((b,i)=>{
  b.x+=b.vx;

  if(player.shield && hit(player,{x:b.x,y:b.y,w:6,h:6})){
    bullets.splice(i,1);
    return;
  }

  if(hit(player,{x:b.x,y:b.y,w:6,h:6})){
    bullets.splice(i,1);
    damagePlayer();
  }
});

// Shooting
if(keys[" "]&&player.shootCooldown<=0){
  playerBullets.push({
    x:player.x+player.w/2,
    y:player.y+30,
    vx:player.facing*10
  });
  player.shootCooldown=20;
}
if(player.shootCooldown>0)player.shootCooldown--;

playerBullets.forEach((b,i)=>{
  b.x+=b.vx;
  level.enemies.forEach((e,ei)=>{
    if(hit({x:b.x,y:b.y,w:6,h:6},e)){
      level.enemies.splice(ei,1);
      playerBullets.splice(i,1);
    }
  });
});

// Coins
level.coins.forEach(c=>{
  if(!c.collected && hit(player,{x:c.x,y:c.y,w:16,h:16})){
    c.collected=true;
  }
});

// Trophy
if(level.coins.every(c=>c.collected) && hit(player,level.trophy)){
  levelComplete=true;
  setTimeout(()=>{
    levelNumber++;
    level=generateLevel(levelNumber);
    player.x=120;
    player.y=200;
    levelComplete=false;
  },1000);
}

// Invincibility
if(player.invincible){
  player.invTimer--;
  if(player.invTimer<=0)player.invincible=false;
}

if(player.y>canvas.height)gameOver=true;

cameraX=player.x-200;
}

function draw(){
ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.save();
ctx.translate(-cameraX,0);

ctx.fillStyle="#654321";
level.platforms.forEach(p=>ctx.fillRect(p.x,p.y,p.w,p.h));

ctx.fillStyle="darkred";
level.spikes.forEach(s=>{
  for(let i=0;i<s.w;i+=20){
    ctx.beginPath();
    ctx.moveTo(s.x+i,s.y+s.h);
    ctx.lineTo(s.x+i+10,s.y);
    ctx.lineTo(s.x+i+20,s.y+s.h);
    ctx.fill();
  }
});

ctx.fillStyle="gold";
level.coins.forEach(c=>{
  if(!c.collected){
    ctx.beginPath();
    ctx.arc(c.x+8,c.y+8,8,0,Math.PI*2);
    ctx.fill();
  }
});

ctx.fillStyle="#444";
level.enemies.forEach(e=>ctx.fillRect(e.x,e.y,e.w,e.h));

ctx.fillStyle="black";
bullets.forEach(b=>ctx.fillRect(b.x,b.y,6,6));

ctx.fillStyle="orange";
playerBullets.forEach(b=>ctx.fillRect(b.x,b.y,6,4));

ctx.fillStyle="gold";
ctx.fillRect(level.trophy.x,level.trophy.y+20,level.trophy.w,10);
ctx.beginPath();
ctx.arc(level.trophy.x+15,level.trophy.y+15,15,0,Math.PI);
ctx.fill();

if(player.invincible && Math.floor(player.invTimer/5)%2===0){
  ctx.fillStyle="#aaa";
}else{
  ctx.fillStyle="#111";
}
ctx.fillRect(player.x+15,player.y+18,15,45);
ctx.fillRect(player.x+10,player.y,25,18);
ctx.fillRect(player.x,player.y+45,15,35);
ctx.fillRect(player.x+30,player.y+45,15,35);

// Glide wings
if(player.gliding){
  ctx.fillStyle="white";
  ctx.fillRect(player.x-20,player.y+20,20,10);
  ctx.fillRect(player.x+45,player.y+20,20,10);
}

if(player.shield){
  ctx.strokeStyle="rgba(0,150,255,0.7)";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(player.x+player.w/2,player.y+player.h/2,50,0,Math.PI*2);
  ctx.stroke();
}

ctx.restore();

ctx.fillStyle="black";
ctx.font="20px Arial";
ctx.fillText("Lives: "+player.lives,20,30);
ctx.fillText("Shield: "+Math.floor(player.shieldEnergy),20,55);
ctx.fillText("Level: "+levelNumber,20,80);

if(gameOver){
  ctx.font="50px Arial";
  ctx.fillText("GAME OVER",400,260);
  ctx.font="22px Arial";
  ctx.fillText("Press CTRL + R to Restart",360,300);
}
}

function loop(){
update();
draw();
requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
